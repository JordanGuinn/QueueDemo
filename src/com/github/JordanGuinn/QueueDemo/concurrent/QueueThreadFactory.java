package com.github.JordanGuinn.QueueDemo.concurrent;

import com.github.JordanGuinn.QueueDemo.model.BoundedQueue;

import java.util.concurrent.CountDownLatch;
import java.util.function.Supplier;

/**
 * The <code>QueueThreadFactory</code> class is responsible for generating the various types of immediately
 * executable <code>Thread</code>s for the <code>BoundedQueue</code> implementation.
 */
public class QueueThreadFactory<T> {
    private final BoundedQueue<T> queue;
    private final Supplier<T> supplier;

    private final ThreadGroup consumerThreadGroup = new ThreadGroup(QueueThreadType.Consumer.name());
    private int consumerThreadCount = 0;

    private final ThreadGroup producerThreadGroup = new ThreadGroup(QueueThreadType.Producer.name());
    private int producerThreadCount = 0;

    /**
     * Constructs a new QueueThreadFactory instance.  Any threads generated by this newly created factory
     * will operate on the BoundedQueue provided.
     *
     * @param _queue    The BoundedQueue for which threads generated by this factory are to operate upon
     * @param supplier  The mechanism by which instances of T are produced
     */
    public QueueThreadFactory(BoundedQueue<T> _queue, Supplier<T> supplier) {
        this.queue = _queue;
        this.supplier = supplier;
    }

    /**
     * Create a new <code>Producer</code> or <code>Consumer</code> thread according to the specified ThreadType,
     * responsible for either adding or removing n (elementCount) elements to this factory's queue.
     *
     * @param threadType    The type of thread to be created
     * @param elementCount  The total number of elements this newly generated queue thread will be responsible
     *                      for either producing or consuming
     *
     * @return  Either a Producer or Consumer Thread ready to apply n (elementCount) elements to this factory's queue
     */
    public Thread getThread(QueueThreadType threadType, int elementCount) throws IllegalArgumentException {
        return getThread(threadType, elementCount, null);
    }

    /**
     * Generate either a new <code>Producer</code> thread or a new <code>Consumer</code> thread based on the
     * ThreadType provided.  Either way, the newly generated thread will be responsible for adding/removing
     * n (elementCount) elements from this factory's stored queue, along with decrementing the provided CountDownLatch
     * once this is complete.
     *
     * @param threadType    The type of thread to be created
     * @param elementCount  The total number of elements this newly generated queue thread will be responsible
     *                      for either producing or consuming
     * @param latch         The CountDownLatch to be decremented upon completion of the Thread returned
     *
     * @return  Either a Producer or Consumer Thread ready to apply n (elementCount) elements to this factory's queue
     */
    public Thread getThread(QueueThreadType threadType, int elementCount, CountDownLatch latch) throws IllegalArgumentException {
        if (threadType == null) {
            throw new IllegalArgumentException("QueueThreadType required to create Thread");
        }

        Thread thread;
        String threadName;

        switch (threadType) {
            case Consumer:
                threadName = QueueThreadType.Consumer.name() + "-" + consumerThreadCount;
                thread = new Thread(consumerThreadGroup, new Consumer<>(queue, elementCount, latch), threadName);

                consumerThreadCount++;
                break;
            case Producer:
                threadName = QueueThreadType.Producer.name() + "-" + producerThreadCount;
                thread = new Thread(producerThreadGroup, new Producer<>(queue, supplier, elementCount, latch), threadName);

                producerThreadCount++;
                break;
            default:
                throw new IllegalArgumentException("Invalid ThreadType provided");
        }

        return thread;
    }
}
